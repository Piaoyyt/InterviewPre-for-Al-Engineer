# Python相关的语法知识


## 1.类的高级话题

### 1.1slot介绍
> 类里面的slot是用来限制类的合法属性集的，类的实例只能给其赋在slot里面
> 的属性的值，如果给不在slot里面的非法属性赋值就会出错。
1. 当某个类继承一个带有slot的父类，那么子类就会自动变成slotted而且获得父类的slot，即取并集，
但是必须子类里面也定义了slot，否则默认是创建实例的__dict__。


### 1.2属性描述符
> 即给类的属性加上一个property的描述符，本质上就是给类的属性
> 加一个类的装饰器，使得类的实例去访问该属性的时候(即通过.符号去访问，属性值的查找、修改、删除等，通过
> 实例的'dict'属性去访问不会调用描述符)，能够调用到相应的被修饰部分，通过相应的函数去得到想要的结果。
1. 描述符分为数据和非数据，非数据描述符即实现了get操作，属性获取部分；数据描述符则是实现了set和delete
两部分，两种不同形式会对实例字典dict里面的属性会造成不同的影响，数据描述符会直接覆盖掉dict里面的属性 
，而非数据的则可能被dict里面的属性覆盖掉，具体原因就是因为在通过.符号去访问类的属性的时候，本质上是
1.先判断是否有get实现，有的话继续判断是否有set或者delete，有的话直接返回，2.否则下一步直接从dict里面去查找，
有的话直接返回；3.再判断是否有get，有的话返回get相应的值。
### 1.3新式类的变化

> python3.X里面所有的类都是新式类，至于为什么叫新式类，主要有以下几点变化。
1. 针对内置属性的访问：经典类对于类的内置属性的访问会先经过getattr，即先被其拦截，然后再调用内置属性，
但是新式类会直接调用内置的函数，经典比如str()，一个是getattr→\__str\__()，另一个是\__str\__()。
2. 添加内置操作：经典类可以直接通过类实例去添加内置的函数，而新式类不可以这样添加。
3. class的变化：新式类里面任何的类都是type的一个实例，即默认下type是任何一个类的元类。
4. type的变化：新式类里面type本身也是一个类实例，不同类下的实例的type是不一样的，但是经典类里面不同类的实例
都拥有相同的type
   > 任意一个自定义的类默认是以type为元类，即是type的一个实例对象，所以type(自定义的类名称)将返回的是type，
   > 而type(类实例）返回的自定义的类名称。
5. 继承的方式：新式类是广度优先搜索，经典类是深度优先搜索。
6. slot的引入：节约内存，减少不必要的开销。
7. 属性描述符：方便对类里面的属性进行访问控制。

## 积累问题

### 1.拆包问题
可迭代元素可以通过赋值的方式拆包给左边各个变量，比如  
a,*b,c = range(5)；  
lis = ['1','2']  
a,b = list(map(int,lis))；
> 1、`*`args和`**`kwargs 这两个是python中方法的可变参数。
> 2、`*`args表示任何多个无名参数，它是一个tuple； 
> 3、`**`kwargs表示关键字参数，它是一个dict。并且同时使用`*`args和`**`kwargs时，
> 必须`*`args参数列要在`**`kwargs前，像foo(a=1, b='2', c=3, a', 1, None, )
> 这样调用的话，会提示语法错误“SyntaxError: non-keyword arg after keyword arg”。 
> 4、当方法的参数不确定时，可以使用`*`args 和`**`kwargs

