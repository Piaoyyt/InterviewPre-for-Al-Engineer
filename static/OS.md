# 计算机操作系统核心知识点



## <a id = 'ProThread'></a>1.进程和线程
### <a id="Concept"></a>1.1.概念
- 进程
  > 所谓的进程可以理解为计算机里面的程序，是操作系统分配资源的基本单位，即对于每一个进程，
  > 计算机会给其分配一块程序空间（由用户空间和内核空间构成），也即我们称之的虚拟内存空间，为什么称为虚拟内存空间，是
  > 因为对于用户程序来说，计算机的所有的内存都是可用的，而给程序提供的空间只是一个虚拟的地址，
  > 即不是真正意义上的物理内存空间，这块虚拟内存空间必须通过内存管理单元才能映射到实际的物理
  > 空间里面去。这样做的话相当于对实际的内存做了一个封装，避免程序直接对物理内存进行操作避免
  > 一些错误，使得内存能够得到更好的管理。
- 线程
  > 线程是依赖于进程的，即一个进程里面可以存在多个线程，线程可以看作是进程里面不同的工作流，即负责
  > 一个程序里面不同子模块功能的部分，比如QQ里面负责发送信息和窗口、负责加好友的功能等，同一个进程
  > 里面的不同线程会共用这个进程里面的代码块、数据块、文件等资源，同时也会有自己的寄存器、栈空间。
- 两者之间的主要区别  
  1. 进程为资源分配的单元，可以理解为进程是获取整块内存空间的合法申请者；而线程是调度的基本单位，可以
  理解为是能够被系统调度即被系统掌控的单位（协程是线程里面更轻量级的，受程序里面的线程库函数控制，对于
  系统来说是直接控制不了的）。
  2. 每一个进程都有独立的内存空间，但是同一个进程里面的线程会共用进程里面的代码、数据、文件部分，仅仅
  部分比如寄存器、栈空间是独自拥有的。
  3. 由于进程的空间是独立的，所以在进程进行切换的时候需要去切换页表，即经过内存管理单元去查询，查询不到
  的话还会发生缺页异常，会从内存里面再去发生页面的置换，而同一个进程的线程是共用进程的空间的，所以线程切换
  不需要去查询和置换，所以进程的上下文切换比线程的上下文切换更耗时。
  4. 进程之间的通信都需要经过内核，因为不是同一个内存空间里面，需要内核参与去通信；而同一个进程里面的线程
  通信不需要经过内核。
### <a id="CommunicationWay"></a>1.2.进程和线程通信的方式
  
- 管道
  > 所谓的管道，其实就是内核里面的一个文件。管道是单向传输的，即一端进一端出，因为如果两端都能够进的话，会导致
接收端出现混乱，所以现在的管道都是半双工模式（所谓的半是指一端只能进或出，所谓的双是指该管道可以接收和发送）。
管道可以分为两种：匿名管道和有名管道。匿名管道是指父子进程之间的通信管道，而有名管道没有这个限制。
- 消息队列
  > 我们知道管道的传输效率不高，因为管道从一端到另一端肯定是需要时间，而消息队列则可以实现高效的写入同时读取，
所谓的消息队列，即存储消息体的链表，满足队列的先入先出特性，消息队列存在于内核里面，其存在的生命周期随内核，如果
没有去释放或者没有关闭操作系统，消息队列会一直存在。  
  > 同样消息队列也存在通信效率不高的问题，并且不适合传输大数据。
- 共享内存
  > 所谓的共享内存即共用一块物理内存，那么两个进程就可以同时访问该内存里面的资源。
- 信号量
  > 所谓的信号量实际上就是整型的计数器，是通过控制整型值的大小来去控制进程访问资源的权限，因为在多个进程对同一块
内存进行访问的时候，就存在互斥和同步的问题，如何有效的解决这类问题，就可以通过信号量的方式解决。信号量里面主要是
P和V操作，其中P是对信号量进行-1操作，而V是对信号量进行+1操作，同时如果执行完P操作后的信号量<0说明此时资源已经被其它
的进程占用，该进程阻塞等待；如果执行V操作后信号量<=0，表面当前有阻塞的进程，会尝试唤醒。总之就是通过一个整型的值
来去决定该进程是否能够向下继续执行。对于互斥问题，初始化信号量为1，对每一个进程都首尾加上PV即可，同一时刻只能有一个进程
执行；对于同步问题，初始化信号量为0，一个首执行P，一个尾执行V，当V执行完之后P执行才可继续往下执行。
- socket
  > socket是网络通信里面的方式，本质上就是一个文件，负责连接的监听和建立。根据通信协议的不同，socket类型也会有差别。
对于TCP传输控制协议来说，会有两种socket，一个负责来监听、一个负责来连接，经过三次握手建立好连接之后，就开始进行数据的传输。
而UDP传输协议就比较简单了，不需要用socket进行监听和连接，只需要绑定相应的端口号，然后直接进行传输，
- 信号
  > 信号其实是在系统出现异常的时候通知正在工作当中的进程，使得当前的进程去响应信号（可以忽略某些信号，但是对于某些信号是
无法忽略的）
### <a id="SoluforConflict"></a>1.3.多线程或多进程冲突的解决办法
> 多进程和多线程在不同的场景下能够提高任务的运转效率，但是同时也会带来一些问题，竞争和协同就是两类典型的问题，所谓竞争，
就是多个抢占同一块资源的问题，而协同就是多个运行的前后顺序如何保证的问题，针对这两个问题，通常用信号量和锁两种方式来解决。
- 锁
  > 所谓的锁，即对特定的资源区的控制权，凡是获得了指定资源的锁的程序，都可以继续执行，拥有着对该资源区的访问权限；而其它没有
获得锁的程序就必须等待直到锁被释放才去尝试获取锁。
- 信号量
  > 信号量前面已经介绍过，本质上就是一个整型变量的计数器，有相应的P和V操作，来实现互斥和同步。
### <a id="DeadLock"></a>1.4 死锁
> 所谓的死锁指的是程序在争夺锁的过程中出现了死循环的情况，即任何一方不会释放锁，另一方也不会获得到锁。
死锁发生的四大条件：  
- 互斥
  > 同一时刻只能一个进程或线程持有锁，即访问某一资源
- 持有并等待
  > 进程持有一个锁，但是又想访问另一资源，但是另一资源的锁已经被别的进程抢占而去，只能等待。
- 不可剥夺
  > 进程一旦拥有了锁，就拥有了该锁对应的资源的使用权，而且不可以被剥夺。
- 环路等待
  > 满足上述条件的进程出现了环路，即都处于等待的状态中。  
> 而要想避免死锁的发生，也是根据死锁出现的四大条件来去设计，比如：
- 破坏持有并等待
  > 一个进程在开始执行时就分配所有需要的资源，那么就不存在后面等待申请其它资源的情况发生；或者在进程执行的时候动态分配资源并不占用
系统资源。
- 破坏不可剥夺
  > 死锁里面进程如果拥有了部分资源的访问权，那么就会一直拥有这个资源的锁，并且其它的进程不能够来去获得锁，所以在这个情况下，等待进程
的资源可以被隐式释放，别的进程可以访问，那么就不会陷入循环等待的状况，即破坏了不可剥夺条件。
- 破坏环路等待
  > 即采用资源有序分配的方式，即让不同进程获取资源的顺序一样，那么就可以了，就不会出现环路的现象。

### <a id="OtherLock"></a>1.5 读写、乐观、悲观锁
- 读写锁
  > 对于读操作没有限制，即多个进程可以同时进行读操作，但是一旦有进程执行写操作，其它的都进入阻塞，同时给里面还
分为读优先和写优先两种情况，所谓的读优先，指的是读进行的时候，如果有写操作，此时写操作阻塞，但是后面的读还是可以优先
于写；写优先是指后面的读只有等前面的写执行完之后才读。

- 悲观和乐观锁
  > 所谓的悲观和乐观，其实就是在于一个先验的假设，悲观认为多个线程同时修改共享的资源概率比较大，所以对于每一个进程或者线程访问
资源时都需要加锁；而乐观锁则认为修改的概率很低，所以不需要加锁，而是在修改后看是否有其他的进、线程修改，如果有就放弃此次修改。
## <a id = '=MemoryManage'></a>2.内存管理
> 操作系统是高层的应用和底层的硬件设备互相交互的桥梁，而交互重要的就是各类数据，这些数据都是存储在实际的存储设备里面，这些存储设备
可以大致分为高速缓存、内存、外存几大类，而内存是计算机程序运行时代码和数据所存放的位置，因为内存的空间不像缓存那么小，同时速度又不像
外村那么慢，所以最适合来保存运行时的各类数据，我们所说的运行内存就是这个内存。但是对于高层的应用来说，不可能直接将底层的物理内存地址
暴露出来让其使用，因为这样一方面不安全，不同的应用程序都能直接操作实际的物理内存，另一方面也不好去管理，所以对于应用程序来说，可见的
只是虚拟内存，是对物理内存加的一个封装，虚拟内存需要经过映射得到实际的物理内存。
## <a id = '=MemoryAssignMethods'></a>2.1内存分配方式

- 段式存储
  > 段即将程序分成各个段去分开存储，代码段、数据段、堆段、栈段，在去映射的时候会根据不同的段号和段内偏移量去得到实际的物理内存地址，按照分段
的方式去对内存进行分配，容易出现外部碎片的情况，即没有足够大的空间供外部程序去使用，这就需要通过不断的内存交换（内存和外存主要是硬盘的数据交换）来调整
内存分配的位置，效率低下。
- 页式存储

## <a id = 'DeviceManage'></a>3.设备管理

## <a id = 'FileSystem'></a>4.文件系统

## <a id = 'NetSystem'></a>5.网络系统
### <a id="ZeroCopy"></a>5.1 零拷贝
### <a id="Multiplexing"></a>5.2 I/O多路复用
### <a id="ConsistentHashing"></a>5.3 一致性哈希


## <a id = 'ScheduleAl'></a>6.调度算法
